---
# Copyright (C) 2012 Benjamin Feng
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

layout: default
title: Pong
tail: |
  <script>
    var TAU = 2*Math.PI;

    /* Yet another complex number implementation. */
    function Complex(real, imag, mag, dir) {
      if(!(this instanceof Complex)) { return new Complex(real, imag, mag, dir); }

      this.real = real;
      this.imag = imag;
      this.mag = mag;
      this.dir = dir;
    }

    $.extend(Complex, {
      rect: function(real, imag) {
        return new this(real, imag).recalcPolar();
      },

      polar: function(mag, dir) {
        return new this(0, 0, mag, dir).recalcRect();
      }
    });

    $.extend(Complex.prototype, {
      clone: function() {
        return new Complex(this.real, this.imag, this.mag, this.dir);
      },

      recalcRect: function() {
        this.real = this.mag*Math.cos(this.dir);
        this.imag = this.mag*Math.sin(this.dir);
        return this;
      },

      recalcPolar: function() {
        this.mag = Math.sqrt(this.real*this.real + this.imag*this.imag)
        this.dir = Math.atan(this.imag / this.real);
        return this;
      },

      sAdd: function(c) {
        this.real += c.real;
        this.imag += c.imag;
        return this.recalcPolar();
      },

      sMult: function(c) {
        if(c.dir) {
          this.mag *= c.mag;
          this.dir += c.dir;
          return this.recalcRect();
        } else {
          var mag = c.mag || c;
          this.real *= mag;
          this.imag *= mag;
          this.mag *= mag;
          return this;
        }
      },

      sReflectReal: function(c) {
        this.real = -this.real;
        return this;
      },

      sReflectImag: function(c) {
        this.imag = -this.imag;
        return this;
      },

      mult: function(c) {
        return this.clone().sMult(c);
      }
    });

    function pong(field, fieldwidth, fieldheight, ballsize) {
      var $field = $(field);
      $field.css('width', fieldwidth);
      $field.css('height', fieldheight);

      var $ball = $('<div class="ball" />').appendTo($field);
      $ball.pos = Complex.rect(0, 0);
      $ball.vel = Complex.polar(200, TAU * (-4/9 + 3/9*Math.random()));

      $ball.css({width:      ballsize,      height: ballsize,
                 marginLeft: -ballsize/2,   marginTop: -ballsize/2,
                 left:       fieldwidth/2,  top: fieldheight/2});

      function projection() {
        var horiWall = ($ball.vel.real > 0 ? 1 : -1) * (fieldwidth/2 - ballsize/2);
        var vertWall = ($ball.vel.imag > 0 ? 1 : -1) * (fieldwidth/2 - ballsize/2);

        var horiSecTarget = (horiWall - $ball.pos.real) / $ball.vel.real;
        var vertSecTarget = (vertWall - $ball.pos.imag) / $ball.vel.imag;

        var secTarget;
        if(horiSecTarget < vertSecTarget) {
          secTarget = horiSecTarget;
          $ball.pos.sAdd($ball.vel.mult(horiSecTarget));
          $ball.vel.real = -$ball.vel.real;
          $ball.vel.recalcPolar();
        } else {
          secTarget = vertSecTarget;
          $ball.pos.sAdd($ball.vel.mult(vertSecTarget));
          $ball.vel.imag = -$ball.vel.imag;
          $ball.vel.recalcPolar();
        }
        $ball.animate({left: fieldwidth/2 + $ball.pos.real, top: fieldheight/2 - $ball.pos.imag}, secTarget*1000, 'linear', projection);
      }

      projection();
    }

    pong('#field', 400, 400, 10);
  </script>
---
<noscript>NO PONG 4U</noscript>
<div id='field'></div>
